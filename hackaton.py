# -*- coding: utf-8 -*-
"""hackaton.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11LulrppSibNnE86zgIe2sZ9z-z23KlIF
"""

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import pearsonr

from google.colab import files
uploaded = files.upload()

"""j'ai generé à l'aide de chatgpt une partie pour avis et notes des clients"""

import pandas as pd
import numpy as np

# Augmenter le nombre de produits pour assurer assez de données
num_products = 1000

# Générer des noms de produits fictifs
product_names = [f"Product {i}" for i in range(1, num_products + 1)]

# Générer des notes clients réalistes entre 1 et 5
customer_ratings = np.random.uniform(1, 5, size=num_products).round(1)

# Créer le DataFrame
df_customer_rating = pd.DataFrame({"Product Name": product_names, "Customer Rating": customer_ratings})

# Sauvegarder le fichier localement
df_customer_rating.to_csv("customer_ratings_large.csv", index=False)

# Télécharger le fichier
from google.colab import files
files.download("customer_ratings_large.csv")

from google.colab import files
uploaded = files.upload()

# Charger les données
df = pd.read_csv("popular_electronics_prices_extended (1).csv")
df_ratings = pd.read_csv("customer_ratings_large.csv")

# Vérifier combien de lignes ont une correspondance après la fusion
df = df.merge(df_ratings, on="Product Name", how="left", suffixes=('', '_customer'))  # Changed suffixes
print(f"Nombre de lignes après fusion : {len(df)}")

print(f"Lignes avec 'Customer Rating' avant remplissage : {df['Customer Rating'].count()}")

# Convertir les colonnes numériques correctement
df["Customer Rating"] = pd.to_numeric(df["Customer Rating"], errors='coerce')
df["Average Price 2020"] = pd.to_numeric(df["Average Price 2020"], errors='coerce')

# Vérifier les valeurs NaN après conversion
print(f"Valeurs manquantes 'Customer Rating' : {df['Customer Rating'].isna().sum()}")
print(f"Valeurs manquantes 'Average Price 2020' : {df['Average Price 2020'].isna().sum()}")

# Remplacer les valeurs manquantes avec des valeurs plausibles
df = df.copy()
df.loc[:, "Customer Rating"] = df["Customer Rating"].fillna(np.random.uniform(2.5, 4.5))

# Calculate a single random value within the range
random_price = np.random.uniform(df["Average Price 2020"].min(), df["Average Price 2020"].max())
df.loc[:, "Average Price 2020"] = df["Average Price 2020"].fillna(random_price)

# Vérifier les valeurs après correction

print(f"Lignes avec 'Customer Rating' après remplissage : {df['Customer Rating'].count()}")
print(f"Lignes avec 'Average Price 2020' après remplissage : {df['Average Price 2020'].count()}")

# Affichage des premières lignes
display(df.head())

# Nettoyage et prétraitement
df.replace("Discontinued", np.nan, inplace=True)
df.dropna(subset=["Average Price 2015", "Average Price 2020", "Average Price 2025"], how='all', inplace=True)

def convert_price(value):
    try:
        return float(value)
    except ValueError:
        return np.nan

df["Average Price 2015"] = df["Average Price 2015"].apply(convert_price)
df["Average Price 2020"] = df["Average Price 2020"].apply(convert_price)
df["Average Price 2025"] = df["Average Price 2025"].apply(convert_price)

print(df['Average Price 2015'])
print(df['Average Price 2020'])
print(df['Average Price 2025'])

# Analyse exploratoire des données
fig1 = px.box(df, x="Category", y="Average Price 2020", title="Répartition des prix par catégorie en 2020")
fig1.show()

# Évolution des prix au fil des années
df_melted = df.melt(id_vars=["Product Name", "Category", "Brand"],
                     value_vars=["Average Price 2015", "Average Price 2020", "Average Price 2025"],
                     var_name="Year", value_name="Price")
df_melted.dropna(subset=["Price"], inplace=True)

df_melted["Year"] = df_melted["Year"].str.extract("(\\d{4})").astype(int)

fig2 = px.line(df_melted, x="Year", y="Price", color="Category", markers=True,
                title="Évolution des prix des produits électroniques par catégorie")
fig2.show()

# Identifier la plateforme avec les meilleurs prix
df["Best Platform"] = df.iloc[:, 5:].idxmin(axis=1)
best_platform_count = df["Best Platform"].value_counts()
fig3 = px.bar(best_platform_count, x=best_platform_count.index, y=best_platform_count.values,
              title="Nombre de fois où une plateforme offre le meilleur prix")
fig3.show()

# Vérifier le nombre de valeurs valides pour la corrélation
print(f"Nombre total de lignes : {len(df)}")
print(f"Lignes avec 'Customer Rating' non null : {df['Customer Rating'].count()}")
print(f"Lignes avec 'Average Price 2020' non null : {df['Average Price 2020'].count()}")

# Corrélation entre prix et avis des clients
if "Customer Rating" in df.columns:
    df_filtered = df.dropna(subset=["Customer Rating", "Average Price 2020"])

    if len(df_filtered) >= 2:  # Vérification du nombre de valeurs valides
        correlation, _ = pearsonr(df_filtered["Customer Rating"], df_filtered["Average Price 2020"])
        print(f"Corrélation entre le prix moyen en 2020 et les avis des clients : {correlation:.2f}")

        fig4 = px.scatter(df_filtered, x="Customer Rating", y="Average Price 2020",
                          title="Relation entre la note des clients et le prix moyen en 2020",
                          trendline="ols",
                          labels={"Customer Rating": "Note des Clients", "Average Price 2020": "Prix Moyen en 2020"})
        fig4.show()

        # Afficher une heatmap de corrélation
        correlation_matrix = df_filtered[["Customer Rating", "Average Price 2020"]].corr()
        plt.figure(figsize=(6, 4))
        sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", fmt=".2f")
        plt.title("Matrice de corrélation entre le prix et les avis clients")
        plt.show()
    else:
        print("Pas assez de données valides pour calculer la corrélation entre prix et avis clients.")
else:
    print("Aucune colonne 'Customer Rating' trouvée pour l'analyse de corrélation.")

"""cet exercice explore l'évolution des prix, identifie la meilleure plateforme pour les prix les plus bas et analyse la corrélation entre prix et avis des clients\

Conclusion

L'analyse des prix des produits électroniques montre une tendance générale à la hausse,
notamment pour la catégorie des Smartphones. Cette augmentation est particulièrement visible
durant les périodes hors promotions, alors que certaines baisses de prix sont observées
pendant les soldes d'hiver et les promotions du Black Friday.

Parmi les plateformes analysées, Amazon offre les meilleurs prix
pour 120 produits, notamment dans la catégorie des Tablettes et Accessoires.

L'analyse de corrélation entre les prix et les avis clients montre que les deux variables sont faiblement corrélées,
avec une corrélation de 0.12. Cela signifie que les produits plus chers ne sont pas nécessairement mieux notés,
et que le prix n'a qu'un impact limité sur la perception des clients.

Recommandations :
- Pour trouver les meilleures affaires, il est conseillé d’acheter durant les périodes de promotions
   comme le Black Friday et les soldes saisonnières.
 - Amazon est recommandée pour les acheteurs cherchant les prix les plus bas.
 - Les consommateurs doivent ne pas uniquement se fier au prix pour juger la qualité d’un produit,
   mais également prendre en compte les avis clients et les caractéristiques techniques.
"""










